# 分布式共识

---

## 问题描述

共识问题要求多个节点对一个数据值达成一致。举个例子来说，假设一个集群中有5台服务器，其中一台服务器提出put(x,5)的请求，这里的共识问题就是这5台服务器是否都对put(x,5)达成一致，也就是x在这5台服务器上是否都会为5。

----

## 分布式共识算法介绍

分布式共识算法就是解决发生在由多个可能会出错的服务器所构成的系统中的共识问题的算法。应用例子包括分布式数据库系统决定什么事务以什么样的顺序提交、状态机复制和原子广播。

分布式共识算法应该具有以下性质：

- **结束(Termination)：** 正确的进程应该最终决定某个值，也就是说x=val。

- **完整性(Integrity)：** 如果所有的进程都提议x=new_val，那么所有的正确进程都应该决定x=new_val。

- **同意(Agreement)：** 所有正确的进程都应该决定同一个值。

对于实际的系统来说，分布式共识算法应该是：

- **安全的(Safe)：** 在非拜占庭问题的故障模型中，它应该能够解决所有问题，包括乱序、重复、包丢失、分区和网络超时。

- **可用的(Available)：** 只要系统中大多数节点是可用的，彼此能够通信的并且这些节点能和客户端进行通信，这个系统就应该是可用的。

- **不依赖时间的(Not depend on timing)：** 日志的一致性不应该受到时间的影响。

---

## Raft共识算法

### 设计目标

Raft必须提供一个完全的、实际的系统构建基础。并且，它应该是在所有条件下都是安全的，一般操作条件下都是可用的，还需要高效处理一般操作。最重要的是，Raft应该是易于理解的。

### 性质

**选举安全**     Raft确保每个term都只有一个leader。

**Leader只追加**    Leader不会覆写和删除日志项。

**日志匹配**    如果两个日志在index处的日志项的term是相等的，那么该日志项之前的所有日志项也是相同的。

**Leader完全性**    如果一个日志项被leader提交了，那么该日志项在后续的所有term中都会存在。

**状态机安全性**    如果一个状态机在index处提交了一个日志项，那么其他的状态机不会应用在index处不同的日志项。

### 算法

Raft共识算法由三个部分组成：领袖选举、日志同步和日志压缩。

**领袖选举**    当follower超过选举触发时间后没有收到leader的心跳或者candidate超选举触发时间后没有收到收到leader选举成功的信息，那么领袖选举就会产生。candidate投票受到voteFor，term和日志状态的影响。candidate只会投给在本轮中随机选择的或者最先请求的日志不旧于该candidate的candidate。为了解决split brain问题(一轮选举结束时选不出leader)，选举触发时间在每次server成为follower或者进入candidate状态时，都会选出一个范围中的随机时间，这样还能够使得leader选举很快。

**日志复制**     正常工作情况下，leader发送日志，follower直接接受并追加。但当冲突出现后，leader需要通过调整nextIndex来解决日志不一致问题。简单的解决办法是每次出现日志不一致，follower拒绝append然后leader使nextIndex减1即可重发，这种办法存在不必要的过多AppendEntiresRPC请求问题。优化方案请参考：[日志同步优化机制-FastBackup](https://github.com/YinhaoHu/MIT-6.824-2020-Spring/tree/master/src/raft#fast-backup)。

**日志压缩**    每个服务器自主完成日志压缩。leader发送InstallSnapshot来让落后过多的follower跟上leader的快照。
