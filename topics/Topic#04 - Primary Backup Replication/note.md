# Topic #04 - Primary Backup Replication

---

## 基本容错设计(BASIC FT DESIGN)

为了给*主虚拟机(Primary VM)* 提供容错能力，我们让一个*备虚拟机(Backup VM)* 运行在一台物理上不同的服务器上。备虚拟机与主虚拟机保持同步并且相同地执行。只有主虚拟机在网络上公布自己的存在。备虚拟机的输入来源于主虚拟机的所有输入以及为了同步非确定性操作的额外信息，其输出被*管理程序(hypervisor)* 丢弃。论文提供了一个综合*心跳(heartbeating)* 和*监控(monitoring)* 的技术来监测主虚拟机或者备虚拟机是否出现故障，并且确保主虚拟机出现故障时，备虚拟机接管后不会有任何数据丢失。

### 确定性重演实现(Deterministic Replay Implementation)

虚拟机的状态不仅受到确定的输入(比如，网络传输包、磁盘读内容)的影响，还受到不确定的事件(虚拟终端)和不确定的操作(读处理器的始终计数器)的影响。这就要求系统要解决三个问题：1）如何正确的捕获所有的确定输入和不确定的事件和操作；2）如何正确地把捕获到的日志应用于备虚拟机上从而得到与主虚拟机相同的输出和状态改变；3）如何在保证容错的情况下不降低系统性能。

确定性重演通过写日志文件记录主虚拟机的所有输入以及不确定操作和事件。通过记录足够的信息让备虚拟机能够正确重演执行。

### 容错协议(FT Protocol)

确定性重演产生主虚拟机执行的日志项(包括指令序号、指令类型和数据)并通过日志通道将它们发送给备虚拟机。容错协议要求当主虚拟机发生故障时，备虚拟机立刻接管过来并且所有的输出与原虚拟机一致。为保证输出操作正确执行，容错协议要求主虚拟机在执行输出操作前必须要向备虚拟机发送通知，并且受到确认消息后才能真正执行。输出规则并非使主虚拟机停止而是延迟执行输出操作。

在论文提及的容错协议中，输出并没有保证只执行一次，输入也可能会丢包。

### 发现与响应故障(Detecting and Responding to Failure)

容错协议通过让服务器发送UDP心跳消息以及监控日志通道流量来发现故障，一旦超时，容错协议确定是虚拟机发生故障。但这种方法可能产生脑裂问题，论文提到充分利用共享磁盘，提供原子的测试并设置指令来保证只有一个虚拟机为主。

当发现故障后，备虚拟机立刻接管主虚拟机，但它应该重演完主虚拟机故障点之前的日志项，然后在故障点后以正常模式执行。

---

## 容错的实践实现(PRACTICAL IMPLEMENTATION OF FT)

### 启动与重启容错虚拟机(Starting and Restarting FT VMs)

容错协议的虚拟机启动机制能够保证主虚拟机能够在任意状态下启动备虚拟机以及启动过程不会对主虚拟机产生较长的中断影响。

主虚拟机在远程服务器上克隆一份与自己完全相同的运行副本。其中，远程服务器的选择由集群服务考虑集群的资源使用情况和其他限制后来选择。

### 管理日志通道(Managing the Logging Channel)

主虚拟机所在的服务器和备虚拟机所在的服务器上的管理程序各自维护着一个日志缓冲区。用于从日志通道中发送/接受日志时缓冲。当备虚拟机执行过慢时，发送方服务器的管理程序需要进行流量控制，从而避免当备虚拟机接管时，故障转移时间过大。

为了避免备虚拟机执行过于落后，协议要求备虚拟机发送额外信息用于确定主备执行时间差。一旦时间差超过一定阈值，主虚拟机的CPU资源减少，开始一个缓慢的反馈循环用于调整主备执行时间差。

### 在容错虚拟机上的操作(Operations on FT VMs)

需要处理用于主虚拟机上的操作，包括关机、资源管理改变。这些操作首先应用于主虚拟机上，随后发送必要的控制信息给备虚拟机从而使其做出改变。

需要额外注意的是VMotion操作，其保证虚拟机不会移动到另一个虚拟机所在的服务器上。并且在移动前应该让所有的IO操作完成。对于主虚拟机，在VMotion发生时，等待所有的IO完成后即可移动。对于被虚拟机，其应该要求主虚拟机暂时不要发送额外的IO请求，然后等待所有已在处理中的IO请求完成后即可移动。

### 磁盘IO的实现问题(Implementation Issues for Disk IOs)

第一个问题是应用同时访问磁盘或者多IO操作同时访问页会出现竞争问题，从而导致不确定性出现。解决办法是在主备虚拟机上按照同样的序列化顺序进行IO操作。

第二个问题是应用与磁盘操作同时访问内存页也会出现竞争问题。解决办法是使用弹性缓冲区(bounce buffer)。例如，当应用要写入一个内存页时，它应该先写入到弹性缓冲区，等待该页上的IO操作完成后，再把弹性缓冲区复制到该页上。

第三个问题是主虚拟机请求了磁盘IO操作，但该操作还未完成时主虚拟机便发生故障，发生故障转移。解决办法是备虚拟机接管后，再次提交不确定是否完成的磁盘IO操作。

### 网络IO的实现问题(Implementation Issues for Network IOs)

当管理程序异步更新虚拟机的网络设备状态时，可能会导致不确定性出现。解决办法是禁止异步更新，当需要更新时，先让触发陷阱跳转到管理程序，由管理程序将更新内容记录日志后再应用于虚拟机。有两种方法优化禁止异步更新操作后带来的性能损失。一种办法是聚集优化减少陷阱和中断次数。另一种办法是通过将发日志发送函数注册到TCP栈中从而减少发送日志并接受通知的带来的延迟。

---

## 设计选择(DESIGN ALTERNATIVES)

### 共享与非共享磁盘的比较(Shared vs. Non-shared Disk)

与非共享磁盘相比，共享磁盘不需要为同步两个磁盘而实现容错付出代价。但共享磁盘不可用会导致主备都不可用。

### 在备虚拟机上执行磁盘读(Executing Disk Reads on the Backup VMs)

在备虚拟机上执行磁盘读可以在工作负载有大量磁盘IO时大大减小日志通道流量。但这种方法也会出现三个问题：1）可能会让备虚拟机执行变慢；2）需要额外处理备虚拟机磁盘读失败的情况；3）在共享磁盘配置中，如果主先磁盘读，非常小的时间间隔后进行同样位置的磁盘写，会导致备虚拟机读到的数据是不符合预期的。

---

## 总结(CONCLUSION)

将主虚拟机的执行流复制到备虚拟机上，从而让备虚拟机与主虚拟机保持同步，进而实现容错。论文提到两种复制方法：1）状态转移；2）状态机。在论文实现的仅用于单处理器的虚拟机中，选择状态机方法实现主备复制，因为其较状态转移方法能够更好的减小同步开销。

VM FT的基本目标是保证主虚拟机发生故障时，备虚拟机能立刻接管过来而不造成任何的数据损失。为实现这一目标，VM FT通过使用确定性重演(Deterministic Replay)技术来保证备虚拟机的执行流与主虚拟机同步。确定性重演技术要求主虚拟机发送日志与备虚拟机同主虚拟机一样执行。另外，通过心跳和日志通道流量监控的方法来发现故障。

论文提到在实践中需要处理的问题包括：1）如何防止备虚拟机执行落后过多；2）如何能够在任意状态下启动虚拟机；3）如何避免访问磁盘页上的竞争。

VM FT在大多数应用中会造成的性能损失低于10%，日志流量不超过20Mb/s，这能够让VM FT用于长距离主备复制中。
