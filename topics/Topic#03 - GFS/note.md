# Topic#03 - Google File System

---

## 简介(INTRODUCTION)

GFS(Google File Systme) 是谷歌基于传统的分布式文件系统和已有的工作负载与技术环境而设计的分布式文件系统。

* 视组件故障为正常而非异常情况

* 重新审视文件系统的块大小和IO操作

* 大多数文件更新是附加至末尾而非重写已有数据

* 共同设计API与文件系统接口能够提供高灵活性

---

## 设计概况(DESIGN OVERVIEW)

**假设** 主要的观察包括出错情况、文件大小、读写模式、带宽要求和语义。

**接口** GFS支持open, close, read, write, create, snapshot, record append操作。

**架构** 参与者包括Client, ChunckServer 以及 Master。流动数据包括Filename，Chunck Index，Chunck Locations以及Byte Range。

**单一Master** GFS只有一个Master，这一决定能够让系统设计更简单，并且让Master能够做出精细的块放置与复制的决定。

**块大小** 块大小是一个关键的设计参数。在GFS中，块大小为64MB。这样做的优点包括：1）减少客户端与Master的交互次数；2）减少网络流量；3）Master存储的元信息更小。

**元信息** GFS中共有三个元信息：1）块和文件的命名空间；2）文件到块的映射；3）每个块副本的位置。每个块的位置在Master启动时向ChunckServer问询得到。元信息存储在内存中。这使得与元信息相关的操作很快，并且能够让对元信息的定期扫描更为容易。通过操作日志记录Master的状态，从而记录检查点，便于Master的重启。

**一致性模型** 松散一致性模型，保证对高分布式应用的支持，还使得实现比较简单与高效。

---

## 系统交互(SYSTEM INTERACTIONS)

### 租约与突变顺序(Leases and Mutation Order)

租约维护着一个块副本间的一致性突变顺序。由Master发给一个块服务器作为主(主定义一致性突变顺序)，而其他的具有该块副本的块服务器作为辅。租约有一个初始超时时限，当租约超时，该租约的主可能会改变。另外，如果主正在处理突变而租约已超时，那么它可以请求延期。

写控制和数据流的过程大致是：1）客户端向Master询问块的当前租约以及其他副本位置；2）Master告诉客户端主的位置；3）客户端向所有副本发送数据；4）客户端向主发送写请求；5）主向辅发送突变顺序；6）辅告知主已完成突变；7）主告知客户端已完成突变。

版本号的增加发生在Master选择一个主的时候。

### 数据流(Data Flow)

数据流与控制流是解耦的。客户端向一个块服务器链以流水化的方式推送数据，从而充分利用了每个机器的网络带宽。

### 原子记录附加(Atomic Record Appends)

客户端仅提供记录附加的数据而由GFS来选择位置，从而保证记录原子地附加了至少一次。

### 快照(Snapshot)

快照生成一份文件或者目录树的拷贝。用于生成数据集的分支拷贝或者记录检查点。

---

## Master操作(Master Operations)

### 命名空间管理与锁(Namespace Management and Locking)

命名空间是一个查找表，它维护着从全路径名到元信息的映射。这与Unix文件系统的命名空间的目录组织不同。每个命名空间树上的节点都有一个关联的读写锁。

### 副本放置(Replica Placement)

副本放置策略有两个主要目标：1）最大化数据的可靠性和可用性；2）最大化网络带宽利用率。仅仅是在机器间传输块副本不能同时满足这两个目标，还需要在机器架(Machine rack)间传输。

### 创建、再复制、再均衡(Creation, Re-Replication, Rebalancing)

块副本的创建有创建、再复制和再均衡三种原因。

**创建** 在创建块时，Master有三个考虑：1）在低于平均磁盘使用率的块服务器上创建；2）限制块服务器的最近创建次数；3）在机器架间传输。

**再复制** 一旦有块的可用副本数量低于用户指定值，就会从具有这些块的有效块服务器处复制块到新的位置。

条件产生的原因包括有的块由于故障而不可用以及用户增加了用户指定值。块的再复制优先级由这三个考虑决定：1）哪些块的可用副本数量与指定值之差更大；2）哪些块的再复制会造成用户进程阻塞；3）先复制存活文件的块而非最近删除文件的块。

复制块的目的块服务器选择同块的创建。再复制操作应该尽可能小的影响用户的请求处理，因此，1）块服务器和集群的活跃的再复制操作数量需要有限制；2）用于克隆操作的流量需要有限制。

**再均衡** Master会周期性地再平衡块分配：先检查块分配情况，再移动块。通过再均衡，块服务器的块会逐渐增多而非突然填满。

### 垃圾回收(Garbage Collection)

当文件被删除时，Master立即记录删除操作并更新元信息，但并不会要求ChunckServer立刻删除相关块。相反的，该文件只会被重命名为带有删除时间戳的隐藏文件。在Master的常规扫描中，超过一定用户配置时长的这类隐藏文件和孤儿块会被删除。删除操作的指定发生在HeartBeat信息交换中。

这样的垃圾回收方式有三个优点：1）实现简单并且可靠；2）作为后台活动进行，减少系统流量峰值时的压力以及摊销握手阶段进行的活动；3）提供安全措施，避免误删。

### 过时副本检测(Stale Replica Detection)

由于ChunckServer发生故障而导致突变并没有真正发生，所以副本在系统中是过时的。GFS通过块版本号(Chunck Version Number)来检测过时副本。在租约发放的过程中，Master增加块版本号并且告知更新块。随后，Master和这些ChunckServer都更新并持久性记录最新版本号。如果Master发现有块的版本号与记录的最新版本号不一致，那么就视为过时副本并且当该副本不存在，在垃圾回收过程中会真正的清理过时副本。在客户端询问租约或者ChunckServer从其他ChunckServer读取块时，Master发送的信息带有最新块版本号，从而更好地保证过时副本不会被使用。

---

## 容错与诊断(FAULT TOLERANCE AND DIAGNOSIS)

### 高可用性(High Availability)

提供高可用性的策略有两个：1）快速恢复；2）复制

*快速恢复* 服务器快速地恢复状态并且启动。

*块复制* 每个块存储于多个机器架的块服务器中。块复制的等级可以被用户指定。

*Master复制* Master的检查点和操作日志被复制在多台机器上。一旦Master进程意外终止，GFS的监控基础设施会立刻拉起一个新的Master进程。另外，影子Master提供了在Master意外终止时客户端也能正常进行请求读的保障。

### 数据完整性(Data Integrity)

每个块服务器使用校验和来检测存储数据是否损坏。每个块被分为定长的64-KB小块，每个小块有32位校验和。在处理读请求时，块服务器比较校验和和返回。在处理更新请求时，块服务器更新校验和。

在空闲时段，块服务器扫描并且检验校验和。一旦数据损坏的块被发现，Master就会创建新的副本以及删掉损坏的副本。

### 诊断工具(Diagnostic Tools)

通过使用具有可扩展性的、详细的诊断日志，GFS记录所有的重要事件和所有的RPC请求与回复，从而使得问题发现、性能分析变得容易。日志记录是异步进行、连续写入的，再加上其带来的好处，这使得其带来的性能损失变得微不足道。

---

## 补充(SUPPLEMENTARY)

### 强一致性技术(Strong Consistency Technology)

**重复检测(Duplication Detection)** 在客户端请求写的过程中，主发现部分块服务器写入失败，于是告诉客户端此次写请求错误。接下来，客户端重新请求该次写，从而导致部分块服务器出现块重复。该技术用于解决此问题。其做法是此前成功写入的块不会在块服务器上被再次写入。

**两阶段提交(Two-Phase Commit)** 主发送写请求后，存在若干个块服务器写入失败的情况。该技术用于解决此问题。其做法是主先问所有块服务器能否保证写入成功，如果所有辅保证写入成功，主才要求它们真正写。

**再同步(Re-Synchronize)** 主出现故障后，租约的所有者转移给一个辅，于是这个辅成为了新的主。然而，在原主出现故障到转移的时间窗口中，可能有的块服务器已经收到写请求，有的并没有。该技术用于解决此问题。其做法是，新的主再一次同步所有相关块服务器的副本。

### 脑裂(Split Brain)

由于主本身正在正常运行，但是Master和主的网络出现故障，导致Master误认为主出了故障。于是Master选择了新的主，此时出现了两个主，但原有的主仍然和客户端进行通信。这会导致不一致性。

### 难点(Hard Points)

在设计大规模分布式文件系统有以下几个难点：

* 如何提供高性能？

* 如何实现容错处理？

* 如何保证一致性？

---

## 事件描述(Event Description)

> Describe a sequence of events that would result in a client reading stale data

**Case 1**

```
Timeline    Event
    |    Client A holds a list of chunckserver for chunck X.
    |    Client B requests to record append
    |    Primary asks secondaries to append record, but one,let's say 
            chunck server A fails due to lost network message.
    |    Client A read chunck X from chunck server B.
```
